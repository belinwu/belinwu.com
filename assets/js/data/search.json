[ { "title": "小心 getLaunchIntentForPackage() 方法", "url": "/posts/beware-of-getLaunchIntentForPackage/", "categories": "Android", "tags": "", "date": "2019-01-10 15:44:00 +0000", "snippet": " 应用中响应 android.intent.action.MAIN 和 android.intent.category.LAUNCHER 在本文中称为主界面。 本文基于 Android O 问题现象用PackageInstaller安装应用，在安装完成界面里点击打开，应用闪屏页打开后，按Home键回到桌面，点击桌面里的应用图标。问题点：再打开一个闪屏页。问题原因应用中启动别的应用，以上问题场景使用的是 PackageManager#getLaunchIntentForPackage() 这个API，它的实现是：// frameworks\\base\\core\\java\\android\\app\\ApplicationPackageManager.java@Overridepublic Intent getLaunchIntentForPackage(String packageName) { // First see if the package has an INFO activity; the existence of // such an activity is implied to be the desired front-door for the // overall package (such as if it has multiple launcher entries). Intent intentToResolve = new Intent(Intent.ACTION_MAIN); intentToResolve.addCategory(Intent.CATEGORY_INFO); intentToResolve.setPackage(packageName); List&amp;lt;ResolveInfo&amp;gt; ris = queryIntentActivities(intentToResolve, 0); // Otherwise, try to find a main launcher activity. if (ris == null || ris.size() &amp;lt;= 0) { // reuse the intent instance intentToResolve.removeCategory(Intent.CATEGORY_INFO); intentToResolve.addCategory(Intent.CATEGORY_LAUNCHER); intentToResolve.setPackage(packageName); // &amp;lt;- 这里 ris = queryIntentActivities(intentToResolve, 0); } if (ris == null || ris.size() &amp;lt;= 0) { return null; } Intent intent = new Intent(intentToResolve); intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); intent.setClassName(ris.get(0).activityInfo.packageName, ris.get(0).activityInfo.name); return intent;}正常桌面启动某个应用的实现如下：// Launcher3\\src\\com\\android\\launcher3\\AppInfo.javapublic static Intent makeLaunchIntent(Context context, LauncherActivityInfoCompat info, UserHandleCompat user) { long serialNumber = UserManagerCompat.getInstance(context).getSerialNumberForUser(user); return new Intent(Intent.ACTION_MAIN) .addCategory(Intent.CATEGORY_LAUNCHER) .setComponent(info.getComponentName()) .setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) .putExtra(EXTRA_PROFILE, serialNumber);}对比以上两种启动另一个应用的代码实现，可以发现： PackageManager#getLaunchIntentForPackage() 这个API 多了 intentToResolve.setPackage(packageName); 。起始应用A直接使用该方法返回的 Intent 对象去启动目标应用B，该intent会被AMS增加一个flag：FLAG_ACTIVITY_BROUGHT_TO_FRONT，代码如下：// frameworks\\base\\services\\core\\java\\com\\android\\server\\am\\ActivityStarter.java/** * Figure out which task and activity to bring to front when we have found an existing matching * activity record in history. May also clear the task if needed. * @param intentActivity Existing matching activity. * @return {@link ActivityRecord} brought to front. */private ActivityRecord setTargetStackAndMoveToFrontIfNeeded(ActivityRecord intentActivity) { mTargetStack = intentActivity.getStack(); mTargetStack.mLastPausedActivity = null; // If the target task is not in the front, then we need to bring it to the front... // except... well, with SINGLE_TASK_LAUNCH it&#39;s not entirely clear. We&#39;d like to have // the same behavior as if a new instance was being started, which means not bringing it // to the front if the caller is not itself in the front. final ActivityStack focusStack = mSupervisor.getFocusedStack(); ActivityRecord curTop = (focusStack == null) ? null : focusStack.topRunningNonDelayedActivityLocked(mNotTop); final TaskRecord topTask = curTop != null ? curTop.getTask() : null; if (topTask != null &amp;amp;&amp;amp; (topTask != intentActivity.getTask() || topTask != focusStack.topTask()) &amp;amp;&amp;amp; !mAvoidMoveToFront) { mStartActivity.intent.addFlags(Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT); // &amp;lt;- 这里 if (mSourceRecord == null || (mSourceStack.topActivity() != null &amp;amp;&amp;amp; mSourceStack.topActivity().getTask() == mSourceRecord.getTask())) { // We really do want to push this one into the user&#39;s face, right now. if (mLaunchTaskBehind &amp;amp;&amp;amp; mSourceRecord != null) { intentActivity.setTaskToAffiliateWith(mSourceRecord.getTask()); } mMovedOtherTask = true;// ...}如果该B应用启动后置后台，那么会根据B应用的主界面的lauchMode创建或复用任务栈里的对象，会有意想不到的结果。比如：如果B应用的主界面launchMode是standard，那么会有第二个主界面被创建在任务栈里。更详细原因分析请参考文章：关于Android应用回到桌面会重复打开闪屏页解决方案第一种在起始应用A里发起跳转时：Intent intent = context.getPackageManager().getLaunchIntentForPackage(packageName);intent.setPackage(null); // 加上这句代码context.startActivity(intent);第二种在目标应用B的主界面onCreate里，添加：super.onCreate(savedInstanceState);if ((getIntent().getFlags() &amp;amp; Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT)&amp;gt; 0) { /**为了防止重复启动多个闪屏页面**/ finish(); return;}" }, { "title": "剖析Android架构组件之ViewModel", "url": "/posts/decompose-viewmodel/", "categories": "Android", "tags": "ViewModel, Jetpack", "date": "2018-07-15 17:01:00 +0000", "snippet": "ViewModel 是 Android 架构组件之一，用于分离 UI 逻辑与 UI 数据。在发生 Configuration Changes 时，它不会被销毁。在界面重建后，方便开发者呈现界面销毁前的 UI 状态。本文主要分析 ViewModel 的以下3个方面： 获取和创建过程。 Configuration Changes 存活原理。 销毁过程。1. 依赖库implementation &quot;androidx.fragment:fragment:1.0.0&quot;implementation &quot;androidx.lifecycle:lifecycle-viewmodel:2.0.0&quot;implementation &quot;androidx.lifecycle:lifecycle-extensions:2.0.0&quot;2. 主要类与接口import androidx.fragment.app.Fragment;import androidx.fragment.app.FragmentActivity;import androidx.lifecycle.ViewModel;import androidx.lifecycle.AndroidViewModel;import androidx.lifecycle.ViewModelProvider;import androidx.lifecycle.ViewModelProvider.Factory;import androidx.lifecycle.ViewModelProviders;import androidx.lifecycle.ViewModelStore;import androidx.lifecycle.ViewModelStoreOwner;3. ViewModelViewModel 是一个抽象类，类中只定义了一个空实现的 onCleared() 方法。public abstract class ViewModel { /** * This method will be called when this ViewModel is no longer used and will be destroyed. * &amp;lt;p&amp;gt; * It is useful when ViewModel observes some data and you need to clear this subscription to * prevent a leak of this ViewModel. */ @SuppressWarnings(&quot;WeakerAccess&quot;) protected void onCleared() { }}3.1 AndroidViewModelAndroidViewModel 类扩展了 ViewModel 类，增加了 Application 字段，在构造方法初始化，并提供了 getApplication() 方法。public class AndroidViewModel extends ViewModel { private Application mApplication; public AndroidViewModel(@NonNull Application application) { mApplication = application; } /** * Return the application. */ @NonNull public &amp;lt;T extends Application&amp;gt; T getApplication() { return (T) mApplication; }}4. 获取和创建过程分析获取 ViewModel 对象代码如下：ViewModelProviders.of(activityOrFragment).get(ViewModel::class.java)4.1 ViewModelProvidersViewModelProviders 类提供了4个静态工厂方法 of() 创建新的 ViewModelProvider 对象。ViewModelProviders.of(Fragment)ViewModelProviders.of(FragmentActivity)ViewModelProviders.of(Fragment, Factory)ViewModelProviders.of(FragmentActivity, Factory)4.2 ViewModelProviderViewModelProvider 负责提供 ViewModel 对象，类中定义了以下两个字段：private final Factory mFactory;private final ViewModelStore mViewModelStore;先说说这两个类的功能。4.3 ViewModelProvider.FactoryFactory 接口定义了一个创建 ViewModel 的接口 create()，ViewModelProvider 在需要时调用该方法新建 ViewModel 对象。public interface Factory { &amp;lt;T extends ViewModel&amp;gt; T create(@NonNull Class&amp;lt;T&amp;gt; modelClass);}Android 已经内置了2个 Factory 实现类，分别是： AndroidViewModelFactory 实现类，可以创建 ViewModel 和 AndroidViewModel 子类对象。 NewInstanceFactory 类，只可以创建 ViewModel 子类对象。它们的实现都是通过反射机制调用 ViewModel 子类的构造方法创建对象。public static class NewInstanceFactory implements Factory { @Override public &amp;lt;T extends ViewModel&amp;gt; T create(Class&amp;lt;T&amp;gt; modelClass) { try { return modelClass.newInstance(); } catch (InstantiationException e) { throw new RuntimeException(&quot;Cannot create an instance of &quot; + modelClass, e); } catch (IllegalAccessException e) { throw new RuntimeException(&quot;Cannot create an instance of &quot; + modelClass, e); } }}AndroidViewModelFactory 继承 NewInstanceFactory 类，是个单例，支持创建 AndroidViewModel 子类对象。public static class AndroidViewModelFactory extends ViewModelProvider.NewInstanceFactory { private static AndroidViewModelFactory sInstance; public static AndroidViewModelFactory getInstance(Application application) { if (sInstance == null) { sInstance = new AndroidViewModelFactory(application); } return sInstance; } private Application mApplication; public AndroidViewModelFactory(Application application) { mApplication = application; } @Override public &amp;lt;T extends ViewModel&amp;gt; T create(Class&amp;lt;T&amp;gt; modelClass) { if (AndroidViewModel.class.isAssignableFrom(modelClass)) { try { return modelClass.getConstructor(Application.class).newInstance(mApplication); } catch (NoSuchMethodException e) { throw new RuntimeException(&quot;Cannot create an instance of &quot; + modelClass, e); } catch (IllegalAccessException e) { throw new RuntimeException(&quot;Cannot create an instance of &quot; + modelClass, e); } catch (InstantiationException e) { throw new RuntimeException(&quot;Cannot create an instance of &quot; + modelClass, e); } catch (InvocationTargetException e) { throw new RuntimeException(&quot;Cannot create an instance of &quot; + modelClass, e); } } return super.create(modelClass); }}4.4 ViewModelStoreViewModelStore 类中维护一个 Map&amp;lt;String, ViewModel&amp;gt; 对象存储已创建的 ViewModel 对象，并提供 put() 和 get() 方法。public class ViewModelStore { private final HashMap&amp;lt;String, ViewModel&amp;gt; mMap = new HashMap&amp;lt;&amp;gt;(); final void put(String key, ViewModel viewModel) { ViewModel oldViewModel = mMap.put(key, viewModel); } final ViewModel get(String key) { return mMap.get(key); }}4.5 ViewModelStoreOwnerViewModelStore 是来自于 FragmentActivity 和 Fragment，它们实现了 ViewModelStoreOwner 接口，返回当前 UI 作用域里的 ViewModelStore 对象。public interface ViewModelStoreOwner { ViewModelStore getViewModelStore();}在 Fragment 类中的实现如下：public ViewModelStore getViewModelStore() { if (getContext() == null) { throw new IllegalStateException(&quot;Can&#39;t access ViewModels from detached fragment&quot;); } if (mViewModelStore == null) { mViewModelStore = new ViewModelStore(); } return mViewModelStore;}在 FragmentActivity 类中的实现如下：public ViewModelStore getViewModelStore() { if (getApplication() == null) { throw new IllegalStateException(&quot;Your activity is not yet attached to the &quot; + &quot;Application instance. You can&#39;t request ViewModel before onCreate call.&quot;); } if (mViewModelStore == null) { mViewModelStore = new ViewModelStore(); } return mViewModelStore;}4.6 创建 ViewModelProvider回到 of() 方法的实现。public static ViewModelProvider of(FragmentActivity activity, Factory factory) { Application application = checkApplication(activity); if (factory == null) { factory = ViewModelProvider.AndroidViewModelFactory.getInstance(application); } return new ViewModelProvider(activity.getViewModelStore(), factory);}在创建 ViewModelProvider 对象时需要传入 ViewModelStore 和 Factory 对象。若 factory 为 null，将使用 AndroidViewModelFactory 单例对象。4.7 获取 ViewModel 对象调用 ViewModelProvider 对象的 get() 方法获取 ViewModel 对象，如果在 ViewModelStore 里不存在，则使用 Factory 创建一个新的对象并存放到 ViewModelStore 里。public &amp;lt;T extends ViewModel&amp;gt; T get(String key, Class&amp;lt;T&amp;gt; modelClass) { ViewModel viewModel = mViewModelStore.get(key); if (modelClass.isInstance(viewModel)) { return (T) viewModel; } viewModel = mFactory.create(modelClass); mViewModelStore.put(key, viewModel); return (T) viewModel;}5. Configuration Changes 存活原理当 Activity 或 Fragment 被系统重建时，ViewModel 对象不会被销毁，新的 Activity 或 Fragment 对象拿到的是同一个 ViewModel 对象。在 FragmentActivity#onRetainNonConfigurationInstance() 方法中，会将 ViewModelStore 对象保留起来。public final Object onRetainNonConfigurationInstance() { Object custom = onRetainCustomNonConfigurationInstance(); FragmentManagerNonConfig fragments = mFragments.retainNestedNonConfig(); if (fragments == null &amp;amp;&amp;amp; mViewModelStore == null &amp;amp;&amp;amp; custom == null) { return null; } NonConfigurationInstances nci = new NonConfigurationInstances(); nci.custom = custom; nci.viewModelStore = mViewModelStore; nci.fragments = fragments; return nci;}然后在 onCreate() 方法能获取之前保留起来的 ViewModelStore 对象。protected void onCreate(Bundle savedInstanceState) { mFragments.attachHost(null /*parent*/); super.onCreate(savedInstanceState); NonConfigurationInstances nc = (NonConfigurationInstances) getLastNonConfigurationInstance(); if (nc != null) { mViewModelStore = nc.viewModelStore; } // ...}那 Fragment 作用域里是如何实现的呢？在 FragmentActivity 的 onRetainNonConfigurationInstance() 方法中里有这样一句代码：FragmentManagerNonConfig fragments = mFragments.retainNestedNonConfig();实现保留的机制是一样的，只不过放在 FragmentManagerNonConfig 对象中。是在 FragmentManager#saveNonConfig() 方法中将 ViewModelStore 对象保存到 FragmentManagerNonConfig 里的。void saveNonConfig() { ArrayList&amp;lt;Fragment&amp;gt; fragments = null; ArrayList&amp;lt;FragmentManagerNonConfig&amp;gt; childFragments = null; ArrayList&amp;lt;ViewModelStore&amp;gt; viewModelStores = null; if (mActive != null) { for (int i=0; i&amp;lt;mActive.size(); i++) { Fragment f = mActive.valueAt(i); if (f != null) { if (f.mRetainInstance) { if (fragments == null) { fragments = new ArrayList&amp;lt;Fragment&amp;gt;(); } fragments.add(f); f.mTargetIndex = f.mTarget != null ? f.mTarget.mIndex : -1; if (DEBUG) Log.v(TAG, &quot;retainNonConfig: keeping retained &quot; + f); } FragmentManagerNonConfig child; if (f.mChildFragmentManager != null) { f.mChildFragmentManager.saveNonConfig(); child = f.mChildFragmentManager.mSavedNonConfig; } else { // f.mChildNonConfig may be not null, when the parent fragment is // in the backstack. child = f.mChildNonConfig; } if (childFragments == null &amp;amp;&amp;amp; child != null) { childFragments = new ArrayList&amp;lt;&amp;gt;(mActive.size()); for (int j = 0; j &amp;lt; i; j++) { childFragments.add(null); } } if (childFragments != null) { childFragments.add(child); } if (viewModelStores == null &amp;amp;&amp;amp; f.mViewModelStore != null) { viewModelStores = new ArrayList&amp;lt;&amp;gt;(mActive.size()); for (int j = 0; j &amp;lt; i; j++) { viewModelStores.add(null); } } if (viewModelStores != null) { viewModelStores.add(f.mViewModelStore); } } } } if (fragments == null &amp;amp;&amp;amp; childFragments == null &amp;amp;&amp;amp; viewModelStores == null) { mSavedNonConfig = null; } else { mSavedNonConfig = new FragmentManagerNonConfig(fragments, childFragments, viewModelStores); }}该方法的调用顺序是：FragmentActivity#onSaveInstanceState() -&amp;gt; FragmentManager#saveAllState() -&amp;gt; FragmentManager#saveNonConfig()。6. 销毁过程在 FragmentActivity 类的 onDestory() 方法中。@Overrideprotected void onDestroy() { super.onDestroy(); if (mViewModelStore != null &amp;amp;&amp;amp; !isChangingConfigurations()) { mViewModelStore.clear(); } mFragments.dispatchDestroy();}在 Fragment 类的 onDestory() 方法中。public void onDestroy() { mCalled = true; FragmentActivity activity = getActivity(); boolean isChangingConfigurations = activity != null &amp;amp;&amp;amp; activity.isChangingConfigurations(); if (mViewModelStore != null &amp;amp;&amp;amp; !isChangingConfigurations) { mViewModelStore.clear(); }}先判断是否有发生 Configuration Changes，如果没有则会调用 ViewModelStore 的 clear() 方法，再一一调用每一个 ViewModel 的 onCleared() 方法。public final void clear() { for (ViewModel vm : mMap.values()) { vm.onCleared(); } mMap.clear();}7. 总结以上便是 ViewModel 3个主要过程的剖析，这里做一下总结。 通过 ViewModelProviders 创建 ViewModelProvider 对象，调用该对象的 get() 方法获取 ViewModel 对象。 当 ViewModelStore 里不存在想要的对象，ViewModelProvider 会使用 Factory 新建一个对象并存放到 ViewModelStore 里。 当发生 发生 Configuration Changes 时，FragmentActivity 利用 getLastNonConfigurationInstance()、onRetainNonConfigurationInstance() 方法实现 ViewModelStore 的保留与恢复，进而实现 ViewModel 对象的保活。 当 FragmentActivity 和 Fragment 被销毁时，会根据是否发生 Configuration Changes 来决定是否销毁 ViewModel。" }, { "title": "初学Android架构组件之ViewModel", "url": "/posts/learn-viewmodel/", "categories": "Android", "tags": "ViewModel, Jetpack", "date": "2018-07-14 23:23:00 +0000", "snippet": "在 Android 中，Activity 和 Fragment 这类 UI 组件会被系统销毁或重建，未特殊处理的 UI 数据将会丢失。以往处理这类问题时，会使用 onSaveInstanceState() 保存 UI 数据，在 onCreate() 方法里恢复 UI 数据，但是数据的大小和类型有限制。看看下面的2个问题： 对于因手机 Configuration Changes 而被系统重建的界面，为了呈现之前的 UI 状态，采用上述的方式来实现起来会显得过于繁琐、不优雅。 在实践 Separation of Concerns 准则时，UI 组件主要是负责显示 UI 数据、响应系统与视图事件，若再负责数据的加载和管理，会变得臃肿、不易复用。本文的主角 ViewModel 可以很好地解决这些问题。注意：它不是用来代替 onSaveInstanceState()。ViewModelViewModel 抽象类被设计成专门存储和管理 UI 数据，它的定义很简单，类中只有一个空实现的 onCleared()。自定义 ViewModel在 app 模块的 build.gradle 文件里添加依赖。dependencies { implementation &quot;androidx.lifecycle:lifecycle-extensions:2.0.0-beta01&quot;}自定义一个 ViewModel 子类 MainViewModel，它维护一个 UI 状态：loading。class MainViewModel : ViewModel() { /** * The flag indicates that the content is loading or not. */ val loading = false}在 UI 组件的 onCreate() 生命周期里，先使用 ViewModelProviders.of() 方法获取当前 UI 作用域里的 ViewModelProvider 对象。再通过 ViewModelProvider 类提供的 get() 方法获取 ViewModel 对象。class MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) val model = ViewModelProviders.of(this).get(MainViewModel::class.java) }}生命周期ViewModel 的生命周期与 UI 组件的生命周期相关联，如下图所示：当 Activity 被系统重建时，ViewModel 对象不会被销毁，新的 Activity 对象拿到的是同一个 ViewModel 对象。可以很方便的使用 ViewModel 里的 UI 数据将之前的 UI 状态呈现给用户。比如上面的例子，呈现页面加载状态。progressBar.visibility = when (model.loading) { true -&amp;gt; VISIBLE false -&amp;gt; INVISIBLE}当 ViewModel 所在的 UI 组件被真正销毁时，它的 onCleared() 方法会被调用，可以覆盖该方法清理资源。AndroidViewModel当自定义的 ViewModel 类中需要使用应用上下文 Context 时，可以选择继承 AndroidViewModel 类，该类定义了 Application 字段。参考资料 ViewModel Overview" }, { "title": "组合优于继承", "url": "/posts/composition-over-inheritance/", "categories": "编程", "tags": "Java, Go, Kotlin, 组合", "date": "2018-07-11 09:51:00 +0000", "snippet": "《Effective Java 中文版第2版》书中第16条中说到： 继承是实现代码复用的有力手段，但它并非永远是完成这项工作的的最佳工具。继承有什么问题？继承打破了类的封装性，子类依赖于父类中特定功能的实现细节。继承什么时候是安全的 在包的内部是用继承，不存在跨包继承。 专门为了扩展而设计，并且具备很好的文档说明。一个例子实现这样一个HashSet，可以跟踪从它被创建之后曾经添加过几个元素。使用继承实现public class InstrumentedSet&amp;lt;E&amp;gt; extends HashSet&amp;lt;E&amp;gt; { // The number of attempted element insertions private int addCount = 0; public InstrumentedSet() { } public InstrumentedSet(int initCap, float loadFactor) { super(initCap, loadFactor); } @Override public boolean add(E e) { addCount++; return super.add(e); } @Override public boolean addAll(Collection&amp;lt;? extends E&amp;gt; c) { addCount += c.size(); return super.addAll(c); } public int getAddCount() { return addCount; }}类中使用 addCount 字段记录添加元素的次数，并覆盖父类的 add()和 addAll() 实现，对 addCount 字段进行设值。在下面的程序中，我们期望 getAddCount() 返回3，但实际上返回的是6。InstrumentedSet&amp;lt;String&amp;gt; s = new InstrumentedSet&amp;lt;String&amp;gt;();s.addAll(Arrays.asList(&quot;Snap&quot;, &quot;Crackle&quot;, &quot;Pop&quot;));问题出在于：在 HashSet 中，addAll() 的实现是基于 add() 方法的。子类在扩展父类的功能时，如果不清楚实现细节，是非常危险的，况且父类的实现在未来可能是变化的，毕竟它并不是为扩展而设计的。使用组合实现不用扩展现有的类，而是在新的类中增加一个私有字段，引用现有类的实例。这种设计被叫做组合。先创建一个干净的 SetWrapper 组合类。public class SetWrapper&amp;lt;E&amp;gt; implements Set&amp;lt;E&amp;gt; { private final Set&amp;lt;E&amp;gt; s; public SetWrapper(Set&amp;lt;E&amp;gt; s) { this.s = s; } public void clear() { s.clear(); } public boolean contains(Object o) { return s.contains(o); } public boolean isEmpty() { return s.isEmpty(); } public int size() { return s.size(); } public Iterator&amp;lt;E&amp;gt; iterator() { return s.iterator(); } public boolean add(E e) { return s.add(e); } public boolean remove(Object o){ return s.remove(o); } public boolean containsAll(Collection&amp;lt;?&amp;gt; c) { return s.containsAll(c); } public boolean addAll(Collection&amp;lt;? extends E&amp;gt; c) { return s.addAll(c); } public boolean removeAll(Collection&amp;lt;?&amp;gt; c) { return s.removeAll(c); } public boolean retainAll(Collection&amp;lt;?&amp;gt; c) { return s.retainAll(c); } public Object[] toArray() { return s.toArray(); } public &amp;lt;T&amp;gt; T[] toArray(T[] a) { return s.toArray(a); } @Override public boolean equals(Object o) { return s.equals(o); } @Override public int hashCode() { return s.hashCode(); } @Override public String toString() { return s.toString(); }}SetWrapper 实现了装饰模式，通过引用 Set&amp;lt;E&amp;gt; 类型的字段，面向接口编程，相比直接继承 HashSet 类来得更灵活。可以在调用该类的构造方法中传入任意 Set 具体类。扩展该类以实现需求。public class InstrumentedSet&amp;lt;E&amp;gt; extends SetWrapper&amp;lt;E&amp;gt; { private int addCount = 0; public InstrumentedSet(Set&amp;lt;E&amp;gt; s) { super(s); } @Override public boolean add(E e) { addCount++; return super.add(e); } @Override public boolean addAll(Collection&amp;lt;? extends E&amp;gt; c) { addCount += c.size(); return super.addAll(c); } public int getAddCount() { return addCount; }}举一反三注：以下代码均是伪代码，组合方式的实现封装成 Android 库并已开源，名叫 Modapter（ Modular Adapter 之意）。没错，这里打了个广告。先来看看问题。笔者曾开发的某个应用有以下2张截图：详情页面和评论列表页面均复用了评论项的实现。评论列表页面的 GameComentsAdapter。public class GameCommentsAdapter extends RecyclerView.Adapter&amp;lt;BaseViewHolder&amp;gt; { private static final int ITEM_TYPE_COMMENT = 1; private List&amp;lt;Object&amp;gt; mDataSet; @Override public int getItemViewType(int position) { Object item = getItem(position); if (item instanceof Comment) { return ITEM_TYPE_COMMENT; } return super.getItemViewType(position); } protected Object getItem(int position) { return mDataSet.get(position); } @NonNull @Override public BaseViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) { LayoutInflater inflater = LayoutInflater.from(parent.getContext()); if (viewType == ITEM_TYPE_COMMENT) { View itemView = inflater.inflate(R.layout.item_comment, parent, false); return new CommentViewHolder(itemView); } return null; } @Override public int getItemCount() { return mDataSet.size(); }}if-else 方式实现修改 GameComentsAdapter 类，增加对游戏详情项的适配支持。public class GameCommentsAdapter extends RecyclerView.Adapter&amp;lt;BaseViewHolder&amp;gt; { private static final int ITEM_TYPE_COMMENT = 1; private static final int ITEM_TYPE_GAME_DETAIL = 2; private List&amp;lt;Object&amp;gt; mDataSet; @Override public int getItemViewType(int position) { Object item = getItem(position); if (item instanceof Comment) { return ITEM_TYPE_COMMENT; } if (item instanceof GameDetail) { return ITEM_TYPE_GAME_DETAIL; } return super.getItemViewType(position); } protected Object getItem(int position) { return mDataSet.get(position); } @NonNull @Override public BaseViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) { LayoutInflater inflater = LayoutInflater.from(parent.getContext()); if (viewType == ITEM_TYPE_COMMENT) { View itemView = inflater.inflate(R.layout.item_comment, parent, false); return new CommentViewHolder(itemView); } if (viewType == ITEM_TYPE_GAME_DETAIL) { View itemView = inflater.inflate(R.layout.item_game_detail, parent, false); return new GameDetailViewHolder(itemView); } return null; } @Override public int getItemCount() { return mDataSet.size(); }}在游戏详情页面为 RecyclerView 创建一个 GameCommentsAdapter 对象。但该方式会让 GameCommentsAdapter 变得臃肿，也不满足OCP开闭原则。继承方式实现扩展一个 Adapter 至少要实现 getItemViewType()、onCreateViewHolder() 等方法，为了复用 GameComentsAdapter 类中对评论项，详情页面的 GameDetailAdapter 继承该类。class GameDetailAdapter extends GameCommentsAdapter { private static final int ITEM_TYPE_GAME_DETAIL = 2; @Override public int getItemViewType(int position) { Object item = getItem(position); if (item instanceof GameDetail) { return ITEM_TYPE_GAME_DETAIL; } return super.getItemViewType(position); } @NonNull @Override public BaseViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) { if (viewType == ITEM_TYPE_GAME_DETAIL) { LayoutInflater inflater = LayoutInflater.from(parent.getContext()); View itemView = inflater.inflate(R.layout.item_game_detail, parent, false); return new GameDetailViewHolder(itemView); } return super.onCreateViewHolder(parent, viewType); }}突然来了一个新需求产品希望在详情页面添加推荐项，复用首页列表项，如下图所示：实现效果如下图所示：Java 是单继承的，GameDetailAdapter 已经继承了 GameComentsAdapter 类了，无法再继承 HomeAdapter。难道继续在 GameComentsAdapter 类中增加 if 判断？组合方式为了方便阅读，部分代码已省略。定义一个模块化的适配器 Adapter 类，为了能够被以上 Adapter 类所管理，数据项和视图项需要做一些配合：前者继承 AbstractItem 类，后者需要继承 ItemViewHolder 类。class Comment extends AbstractItem {}class GameDetail extends AbstractItem {}class Game extends AbstractItem {}class CommentViewHolder extends ItemViewHolder&amp;lt;Comment&amp;gt; {}class GameDetailViewHolder extends ItemViewHolder&amp;lt;GameDetail&amp;gt; {}class GameViewHolder extends ItemViewHolder&amp;lt;Game&amp;gt; {}AbstractItem 类定义了一个 type 属性，代表数据项的类型，会与通过注册的数据项配置信息进行比对，当 type 属性值一样时，就会为该数据项 AbstractItem 创建对应的视图项 ViewHolder。如果因为 Java 单继承的关系无法继承 AbstractItem 类，可以选择实现 Item 接口，实现以下方法。public interface Item { void setType(int type); int getType();}此时，数据项和视图项的准备工作已完成，接下来可以组合它们实现需求。在评论列表页面，创建一个 Adapter 实例，并添加评论项功能。List&amp;lt;Item&amp;gt; dataSet = new ArrayList&amp;lt;&amp;gt;();dataSet.add(new Comment());dataSet.add(new GameDetail());Adapter adapter = new Adapter();adapter.getManager() .register(ITEM_TYPE_COMMENT, CommentViewHolder.class) .register(ITEM_TYPE_GAME_DETAIL, GameDetailViewHolder.class) .setList(dataSet);在游戏详情页面，创建一个 Adapter 实例，并添加游戏项功能。List&amp;lt;Object&amp;gt; dataSet = new ArrayList&amp;lt;&amp;gt;();dataSet.add(new Comment());dataSet.add(new GameDetail());dataSet.add(new Game());Adapter adapter = new Adapter();adapter.getManager() .register(ITEM_TYPE_COMMENT, CommentViewHolder.class) .register(ITEM_TYPE_GAME_DETAIL, GameDetailViewHolder.class) .register(ITEM_TYPE_GAME, GameViewHolder.class) .setList(dataSet);当某个页面不再支持评论项时，我们只要删除以下代码即可，不会修改到其他地方，满足OCP设计原则。dataSet.add(new Comment());adapter.getManager().unregister(ITEM_TYPE_COMMENT);实现原理引入 ItemManager 接口，统一管理项数据、注册和注销视图项配置信息。public interface ItemManager { ItemManager setList(List&amp;lt;? extends Item&amp;gt; list); &amp;lt;T extends ViewHolder&amp;gt; ItemManager register(int type, Class&amp;lt;T&amp;gt; holderClass); &amp;lt;T extends ViewHolder&amp;gt; ItemManager register(int type, @LayoutRes int layoutId, Class&amp;lt;T&amp;gt; holderClass); ItemManager register(ItemConfig config); ItemManager unregister(int type); &amp;lt;T extends Item&amp;gt; T getItem(int position);}该接口的实现类是 AdapterDelegate，主要实现了getItemViewType，onCreateViewHolder, onBindViewHolder 三个 if-else 重灾区方法。public final class AdapterDelegate implements ItemManager { public int getItemViewType(int position) { Item item = getItem(position); ItemConfig adapter = null; if (item != null) { adapter = registry.get(item.getType()); } if (adapter == null) { // TODO return 0; } return adapter.getType(); } public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { ItemConfig adapter = registry.get(viewType); if (adapter == null) { return null; } int layoutId = adapter.getLayoutId(); layoutId = layoutId == 0 ? adapter.getType() : layoutId; if (layoutId &amp;gt; 0) { View itemView = LayoutInflater.from(parent.getContext()) .inflate(layoutId, parent, false); return createViewHolder(itemView, adapter.getHolderClass()); } return null; } @SuppressWarnings(&quot;unchecked&quot;) public void onBindViewHolder(@NonNull ViewHolder holder, int position) { Item item = getItem(position); if (holder instanceof ItemViewHolder) { ItemViewHolder viewHolder = (ItemViewHolder) holder; viewHolder.setItem(item); viewHolder.onViewBound(item); } }}使用 AdapterDelegate 实现唯一的 Adapter，将主要的代码委托给前者。public class Adapter extends RecyclerView.Adapter&amp;lt;ViewHolder&amp;gt; { private AdapterDelegate delegate = new AdapterDelegate(); @Override public int getItemViewType(int position) { return delegate.getItemViewType(position); } @NonNull @Override public final ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) { return delegate.onCreateViewHolder(parent, viewType); } @Override public final void onBindViewHolder(@NonNull ViewHolder holder, int position) { delegate.onBindViewHolder(holder, position); } public ItemManager getManager() { return delegate; }}延伸在 Java 生态圈之外，有不少组合优于继承的实践。KotlinKotlin 语言有 delegation 机制，可以方便开发者使用组合。interface Base { fun print()}class BaseImpl(val x: Int) : Base { override fun print() { print(x) }}class Derived(b: Base) : Base by bfun main(args: Array&amp;lt;String&amp;gt;) { val b = BaseImpl(10) Derived(b).print()}Kotlin 版 InstrumentedHashSetclass InstrumentedHashSet&amp;lt;E&amp;gt;(val set: MutableSet&amp;lt;E&amp;gt;) : MutableSet&amp;lt;E&amp;gt; by set { private var addCount : Int = 0 override fun add(element: E): Boolean { addCount++ return set.add(element) } override fun addAll(elements: Collection&amp;lt;E&amp;gt;): Boolean { addCount += elements.size return set.addAll(elements) }}GoGo 语言没有继承机制，通过原生支持组合来实现代码的复用。以下分别是 Reader 和 Writer 接口定义。type Reader interface { Read(p []byte) (n int, err error)}type Writer interface { Write(p []byte) (n int, err error)}通过组合可以定义出具备读取和写入的新类型。type ReadWriter interface { Reader Writer}上述的例子是接口组合，也可以是实现组合。(下面的例子来自 Go in Action 一书)type user struct { name string email string}// notify implements a method that can be called via// a value of type user.func (u *user) notify() { fmt.Printf(&quot;Sending user email to %s&amp;lt;%s&amp;gt;\\n&quot;, u.name, u.email)}// admin represents an admin user with privileges.type admin struct { user // Embedded Type level string}// main is the entry point for the application.func main() { // Create an admin user. ad := admin{ user: user{ name: &quot;john smith&quot;, email: &quot;john@yahoo.com&quot;, }, level: &quot;super&quot;, } // We can access the inner type&#39;s method directly. ad.user.notify() // The inner type&#39;s method is promoted. ad.notify()}推荐书籍 Effective Java 中文版第2版 重构 重构与模式 软件设计重构参考资料 Effective Java 中文版第2版 AdapterDelegates OneAdapter" }, { "title": "初学Android架构组件之Lifecycle", "url": "/posts/learn-lifecycle/", "categories": "Android", "tags": "Lifecycle, Jetpack", "date": "2018-06-29 13:54:00 +0000", "snippet": "在开发应用时，我们可能会基于一系列的生命周期实现某种功能。为了复用，也为了不让应用组件变得很臃肿，实现该功能时会选择与生命周期组件解藕，独立成一种组件。这样能够很方便地在应用组件中使用，比如：Activity、Fragment 或 Service。Android 官方把它叫做 lifecycle-aware 组件，这类组件能够感知应用组件生命周期的变化，避免一连串显性的生命周期方法委托调用。虽然可以创建基类，在基类中进行委托调用，但由于 Java 是单继承的，就会存在一定的限制。不然发现，这是一次组合优于继承的实践。为了方便开发者创建 lifecycle-aware 组件，androidx.lifecycle 包提供了一些类与接口。LifecycleLifecycle 类表示Android应用组件的生命周期，是被观察者。这是一个抽象类，它的实现是 LifecycleRegistry 类。另外，它通过使用两类数据来跟踪应用组件的生命周期变化，一种是事件，另一种是状态。Lifecycle.Event 表示生命周期的事件，与应用组件的生命周期回调一一对应，这些事件分别是：ON_CREATE、ON_START、ON_RESUME、ON_PAUSE、ON_STOP、ON_DESTROY、ON_ANY。最后一种事件可以代表前面任意一种。举个例子，当 Activity 的 onCreate() 生命周期方法被调用时会产生 ON_CREATE 事件，观察者可以监听该事件以便处理Activity此时的生命周期。Lifecycle.State 表示生命周期的状态，一共有5种，分别是：INITIALIZED、 DESTROYED、CREATED、STARTED、RESUMED。应用组件初始化之后进入 INITIALIZED 状态，在 onCreate() 生命周期方法调用后进入 CREATED 状态，在 onStart() 生命周期方法调用后进入 STARTED 状态，在 onResume() 生命周期方法调用后进入 RESUMED 状态。事件与状态之间的具体变化关系如下图所示：Lifecycle 对象有3个方法： 添加观察者：void addObserver(LifecycleObserver observer)。 删除观察者：void removeObserver(LifecycleObserver observer)。 获取当前状态：State getCurrentState()。LifecycleOwnerLifecycleOwner 接口表示生命周期所有者，即拥有生命周期的应用组件。通过调用 getLifecycle() 方法能够获得它所拥有的Lifecycle 对象。FragmentActivity 和 Fragment 均已实现该接口，可以直接使用。当然开发者也可以自定义。LifecycleService 和 ProcessLifecycleOwner 是另外两个内置的实现类。LifecycleObserver标记接口 LifecycleObserver 表示生命周期观察者，是 lifecycle-aware 组件。小试牛刀添加依赖新建一个 Android Studio 项目，在 build.gradle 文件里添加 google() 仓库。allprojects { repositories { google() jcenter() }}在 app 模块的 build.gradle 文件里添加依赖。dependencies { def version = &quot;2.0.0-alpha1&quot; implementation &quot;androidx.lifecycle:lifecycle-runtime:$version&quot; annotationProcessor &quot;androidx.lifecycle:lifecycle-compiler:$version&quot;}例子1：打印生命周期方法被调用日志实现观察者。class MyObserver implements LifecycleObserver { private static final String TAG = MyObserver.class.getSimpleName(); @OnLifecycleEvent(Lifecycle.Event.ON_CREATE) public void onCreate() { Log.d(TAG, &quot;onCreate called&quot;); } @OnLifecycleEvent(Lifecycle.Event.ON_START) public void onStart() { Log.d(TAG, &quot;onStart called&quot;); } @OnLifecycleEvent(Lifecycle.Event.ON_RESUME) public void onResume() { Log.d(TAG, &quot;onResume called&quot;); } @OnLifecycleEvent(Lifecycle.Event.ON_PAUSE) public void onPause() { Log.d(TAG, &quot;onPause called&quot;); } @OnLifecycleEvent(Lifecycle.Event.ON_STOP) public void onStop() { Log.d(TAG, &quot;onStop called&quot;); } @OnLifecycleEvent(Lifecycle.Event.ON_DESTROY) public void onDestroy() { Log.d(TAG, &quot;onDestroy called&quot;); } @OnLifecycleEvent(Lifecycle.Event.ON_ANY) public void onAny() { Log.d(TAG, &quot;onCreate | onStart | onResume | onPause | onStop | onDestroy called&quot;); }}在 Activity 中使用该观察者。public class MyActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { // ... getLifecycle().addObserver(new MyObserver()); }}例子2：网络变化观察者实现这样一个 lifecycle-aware 组件，它能够：在 onCreate() 生命周期中动态注册网络变化 BroadcastReceiver，在 onDestory() 生命周期中注销广播接收者，在收到网络变化时能够判断出网络是如何变化的，并通过回调告知使用者。实现观察者。package com.samelody.samples.lifecycleimport android.content.BroadcastReceiverimport android.content.Contextimport android.content.Context.CONNECTIVITY_SERVICEimport android.content.Intentimport android.content.IntentFilterimport android.net.ConnectivityManagerimport android.net.ConnectivityManager.CONNECTIVITY_ACTIONimport android.net.ConnectivityManager.EXTRA_NETWORK_TYPEimport androidx.lifecycle.Lifecycle.Event.ON_STARTimport androidx.lifecycle.Lifecycle.Event.ON_STOPimport androidx.lifecycle.LifecycleObserverimport androidx.lifecycle.OnLifecycleEvent/** * The network observer. * * @author Belin Wu */class NetworkObserver(private val context: Context) : LifecycleObserver { /** * The network receiver. */ private val receiver = NetworkReceiver() /** * The last type of network. */ private var lastType = TYPE_NONE /** * The network type changed listener. */ var listener: OnNetworkChangedListener? = null @OnLifecycleEvent(ON_START) fun onStart() { val filter = IntentFilter() filter.addAction(CONNECTIVITY_ACTION) context.registerReceiver(receiver, filter) } @OnLifecycleEvent(ON_STOP) fun onStop() { context.unregisterReceiver(receiver) } companion object { /** * The network type: None. */ const val TYPE_NONE = -1 /** * The network type: Mobile. */ const val TYPE_MOBILE = 0 /** * The network type: Wi-Fi. */ const val TYPE_WIFI = 1 } /** * The network receiver. */ inner class NetworkReceiver : BroadcastReceiver() { override fun onReceive(context: Context?, intent: Intent?) { val manager = context?.getSystemService(CONNECTIVITY_SERVICE) as ConnectivityManager val oldType = intent?.getIntExtra(EXTRA_NETWORK_TYPE, TYPE_NONE) var newType = manager.activeNetworkInfo.type newType = when { oldType == TYPE_MOBILE &amp;amp;&amp;amp; newType == TYPE_WIFI -&amp;gt; TYPE_NONE oldType == TYPE_WIFI &amp;amp;&amp;amp; newType == TYPE_MOBILE -&amp;gt; TYPE_NONE else -&amp;gt; newType } if (lastType == newType) { return } listener?.invoke(lastType, newType) } }}定义网络变化监听器。package com.samelody.samples.lifecycle/** * The network type changed listener. Called when the network type is changed. * * @author Belin Wu */typealias OnNetworkChangedListener = (Int, Int) -&amp;gt; Unit在 Activity 中使用该观察者。package com.samelody.samples.lifecycleimport android.os.Bundleimport android.util.Logimport androidx.appcompat.app.AppCompatActivity/** * The sample activity. * * @author Belin Wu */class SampleActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val observer = NetworkObserver(this) observer.listener = { from: Int, to: Int -&amp;gt; Log.d(&quot;Sample&quot;, &quot;The network is changed from $from to $to&quot;) } lifecycle.addObserver(observer) }}在 Service 中使用该观察者。package com.samelody.samples.lifecycleimport android.util.Logimport androidx.lifecycle.LifecycleService/** * The sample service. * * @author Belin Wu */class SampleService : LifecycleService() { override fun onCreate() { super.onCreate() val observer = NetworkObserver(this) observer.listener = { from: Int, to: Int -&amp;gt; Log.d(&quot;Sample&quot;, &quot;The network is changed from $from to $to&quot;) } lifecycle.addObserver(observer) }}参考资料 Handling lifecycles with lifecycle-aware components Adding Components to your Project Book: Android’s Architecture Components" }, { "title": "初学Git工作流程", "url": "/posts/learn-git-flow/", "categories": "编程", "tags": "Git", "date": "2018-05-12 16:23:00 +0000", "snippet": "(文中图片均来源于网络)GitGit已是代码版本管理的标配，其分布式、多分支功能让人印象深刻。Git工作流程（Git Workflow）当项目需要多人共同开发时，规范工作流程就变得越来越重要。合适的工作流程能让多人协同开发更加顺利和高效。目前主流的Git工作流程有三种： Git Flow（版本发布） GitHub Flow（持续发布） GitLab Flow（持续发布、版本发布）三种工作流程各有优缺点，对于不同类型的项目有各自的用武之地。笔者开发Android项目时使用的是Git Flow，对此比较熟悉。其余两种工作流程，笔者出于学习的目的，在文中谈谈自己的理解。Git Flow从分支分类开始，有以下几类：长期分支、主要分支 master（主分支）：稳定可发布、产品线 develop（开发分支）：处于开发状态git checkout -b develop mastergit push origin develop短期分支、支持性分支 feature（功能分支） release（发布分支） hotfix（修复分支）feature 功能分支git checkout -b feature-main develop# git commit 1# git commit 2# git commit 3git checkout developgit merge --no-ff feature-maingit branch -d feature-maingit push origin develop–no-ffrelease 发布分支git checkout -b release-1.0 develop# 可能在该阶段再分出 fix-* 分支来修复发布前的问题，会有git commit和 git merge 操作。发布分支已测试完毕，问题已修复，可发布时，将代码同步到master分支中。git checkout mastergit merge --no-ff release-1.0git tag -a v1.0git push origin mastergit push origin v1.0若在发布分支中有修复问题，那么这些提交也要同步到develop分支中。git checkout developgit merge --no-ff release-1.0git push origin develop删除发布分支。git branch -d release-1.0hotfix 修复分支当线上版本有紧急问题需要修复，develop分支还处于下一个版本的开发状态，不好从开发分支分出修复分支，选择从master分出hotfix-*分支来修复该紧急问题。git checkout -b hotfix-1.2.1 mastergit commit -a -m &quot;Bumped version number to 1.2.1&quot;该紧急问题被修复，并验收通过时发布修复版本，同步代码到master分支。git checkout mastergit merge --no-ff hotfix-1.2.1git tag -a v1.2.1git push origin mastergit push origin v1.2.1接着将代码同步到develop分支。git checkout developgit merge --no-ff hotfix-1.2.1git push origin develop删除修复分支。git branch -d hotfix-1.2.1实际操作中，会将master作为开发分支，因为它几乎是Git相关工具的默认分支，可以省去大量切换工作。新建诸如release、production分支作为产品分支。GitHub Flow只有一个长期分支master，很适合持续发布的项目，如：网站，相比Git Flow 更简单、易用。git checkout -b bug47833 mastergit commitgit checkout mastergit merge --no-ff bug47833git push origin masterGitLab Flow只有一个主分支master。该工作流程最大原则是“上游优先”，只有master分支的代码提交，才能应用到下游分支中。在开发需求或修复问题时，可以使用GitHub Flow方式从master分支分出工作分支，开发完成后以合并请求合并到master分支，当验收通过时，就可以合入到下游分支并发布了。持续发布版本发布结束语本文主要介绍了3种Git工作流程，其中重点介绍了Git Flow。目前笔者所在的团队使用的工作流程类似于GitLab Flow，在这里只是简单的介绍，而GitHub Flow工作流程未真正实践过，出现在文中是为了丰富文章内容。文中的Git工作流程并不是全部，完全可以自己按需扩展或全新定义出适合项目的工作流程。参考资料 Git 工作流程 A successful Git branching model GitHub Flow Introduction to GitLab Flow" }, { "title": "初学RxJava", "url": "/posts/learn-rxjava/", "categories": "编程", "tags": "RxJava, Java", "date": "2017-12-03 23:34:00 +0000", "snippet": "什么是RxJava？这个名词包含两部分： Rx(是ReactiveX、Reactive Extensions、Reactive Programming的简称)：An API for asynchronous programming with observable streams. Java: Rx在JVM上实现。在RxJava的GitHub里官方给出了这样的示意： A library for composing asynchronous and event-based programs by using observable sequences.Rx组合了观察者模式、迭代器模式和函数式编程范式思想，所以有时候也将这种编程方法叫做Functional Reactive Programming。Hello worldObservable.just(&quot;Hello&quot;, &quot;world!&quot;) .subscribe(new Consumer&amp;lt;String&amp;gt;() { @Override public void accept(String item) throws Exception { System.out.print(item + &quot; &quot;); } });// Hello world!Observable.just()将传入的2个字符串项转化成一个Reactive Stream，调用subscribe()订阅方法观察该Stream里的数据项。图示如下：Observable和ObserverObservable是一种基于事件推送并且可组合的迭代器，它可以推送3种事件： onNext()：接收推送过来的数据项。 onError()：接收失败事件。 onComplete()：响应流推送已完成。这3种事件与Observer类中的抽象方法一一对应。public interface Observer&amp;lt;T&amp;gt; { void onNext(@NonNull T t); void onError(@NonNull Throwable e); void onComplete();}使用Observer订阅Observable：Observable.just(&quot;Hello&quot;, &quot;world!&quot;) .subscribe(new Observer&amp;lt;String&amp;gt;() { @Override public void onSubscribe(Disposable d) { } @Override public void onNext(String item) { out.print(item + &quot; &quot;); } @Override public void onError(Throwable e) { out.println(&quot;error: &quot; + e.getMessage()); } @Override public void onComplete() { out.println(&quot;done&quot;); } });Observer.onSubscribe()方法的入参Disposable可用来取消订阅。下面使用RxJava提供的DisposableObserver类演示取消订阅功能。Disposable disposable = Observable.just(&quot;Hello&quot;, &quot;world!&quot;) .subscribeWith(new DisposableObserver&amp;lt;String&amp;gt;() { @Override public void onNext(String item) { out.print(item + &quot; &quot;); } @Override public void onError(Throwable e) { out.println(&quot;error: &quot; + e.getMessage()); } @Override public void onComplete() { out.println(&quot;done&quot;); } });// 在适当的时机取消订阅disposable.dispose();OperatorObservable.just()也是一种Operator，它将传入的数据项转化成了响应流。对响应流应用一些Operator可以进行函数式编程、数据转换、过滤等许多功能。mapObservable.just(&quot;Hello&quot;, &quot;world!&quot;) .map(new Function&amp;lt;String, Integer&amp;gt;() { @Override public Integer apply(String item) throws Exception { return item.length(); } }) .subscribe(new DisposableObserver&amp;lt;Integer&amp;gt;() { @Override public void onNext(Integer item) { out.print(item + &quot; &quot;); } @Override public void onError(Throwable e) { out.println(&quot;error: &quot; + e.getMessage()); } @Override public void onComplete() { out.println(&quot;done&quot;); } });create使用create()方法可以自己动手创建响应流。Observable.create(new ObservableOnSubscribe&amp;lt;String&amp;gt;() { @Override public void subscribe(ObservableEmitter&amp;lt;String&amp;gt; e) throws Exception { try { e.onNext(&quot;Hello&quot;); e.onNext(&quot; world!&quot;); e.onComplete(); } catch (Exception ex) { e.onError(ex); } } }) .subscribe(new DisposableObserver&amp;lt;String&amp;gt;() { @Override public void onNext(String item) { out.print(item + &quot; &quot;); } @Override public void onError(Throwable e) { out.println(&quot;error: &quot; + e.getMessage()); } @Override public void onComplete() { out.println(&quot;done&quot;); } }); 使用场景异步操作作为一个Android开发者，我们都知道：不应该阻塞UI线程，应该将耗时的计算放在异步线程中。我们有多种实现方式，这里不再多做说明，直接使用RxJava实现异步操作。Observable.create(new ObservableOnSubscribe&amp;lt;String&amp;gt;() { @Override public void subscribe(ObservableEmitter&amp;lt;String&amp;gt; e) throws Exception { // 该方法将在IO线程里执行 try { e.onNext(&quot;Hello&quot;); e.onNext(&quot; world!&quot;); e.onComplete(); } catch (Exception ex) { e.onError(ex); } } }) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new DisposableObserver&amp;lt;String&amp;gt;() { @Override public void onNext(String item) { // 在UI线程里执行 out.print(item + &quot; &quot;); } @Override public void onError(Throwable e) { // 在UI线程里执行 out.println(&quot;error: &quot; + e.getMessage()); } @Override public void onComplete() { // 在UI线程里执行 out.println(&quot;done&quot;); } });多异步操作现在要实现一个修改头像的需求，分成以下3个步骤来完成： 获取图片上传token； 使用上传token上传图片； 调用修改个人信息接口修改头像信息。很显然这3个操作都需要在异步线程里进行，而且是按顺序一一进行的。通常使用回掉来实现非阻塞异步操作，但随着连续多个异步操作容易引入Callback Hell问题。使用RxJava的flatMap()方法可以优雅地解决这些问题。getUploadToken() .flatMap(token -&amp;gt; uploadImage(token)) .flatMap(imageUrl -&amp;gt; updateUser(imageUrl)) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new DisposableObserver&amp;lt;Boolean&amp;gt;() { @Override public void onNext(Boolean item) { out.print(item + &quot; &quot;); } @Override public void onError(Throwable e) { out.println(&quot;error: &quot; + e.getMessage()); } @Override public void onComplete() { out.println(&quot;done&quot;); } });public Observable&amp;lt;String&amp;gt; getUploadToken() { return Observable.create(e -&amp;gt; { try { String token = &quot;get token from remote server&quot;; e.onNext(token); e.onComplete(); } catch (Exception ex) { e.onError(ex); } });}public Observable&amp;lt;String&amp;gt; uploadImage(final String token) { return Observable.create(e -&amp;gt; { try { String imageUrl = &quot;upload image to remote server with token: &quot; + token; e.onNext(imageUrl); e.onComplete(); } catch (Exception ex) { e.onError(ex); } });}public Observable&amp;lt;Boolean&amp;gt; updateUser(final String imageUrl) { return Observable.create(e -&amp;gt; { try { // update user with image url e.onNext(true); e.onComplete(); } catch (Exception ex) { e.onError(ex); } });}防止连续点击在Android开发中会遇到这样的问题：短时间内快速点击某个按钮，按钮的单击监听器会被多次调用，这样会引入一写异常情况。同样可以使用RxJava的throttleFirst()方法来解决这种问题。RxView.clicks(findViewById(R.id.btn_throttle)) .throttleFirst(1, TimeUnit.SECONDS) .subscribe(aVoid -&amp;gt; { System.out.println(&quot;click&quot;); });参考资料 RxJava RxAndroid RxBinding ReactiveX" }, { "title": "让我心动的Kotlin", "url": "/posts/kotlin-make-my-heart/", "categories": "编程", "tags": "Kotlin", "date": "2017-10-30 23:16:00 +0000", "snippet": "Kotlin是一门务实、简洁和安全的语言，专注于互操作性。注：本文基于Kotlin 1.3编写。Hello world!fun main() { // 1 println(&quot;Hello world!&quot;) // 2}1支持定义 top-level 函数，告别工具类。fun关键字定义函数，参数声明格式是：name: Type。main函数是程序执行的主入口。2println是内置top-level函数，打印消息到标准输出流并换行。不需要;。文档注释支持Markdown/** * 这是`文档注释`，它支持 **Markdown**。 */fun main() { println(&quot;Hello world!&quot;)}变量var定义可变变量，val定义只读变量，初始化后不能再次被赋值。fun main() { var age: Int = 27 val name: String = &quot;Belin Wu&quot;}类型推导可以不写类型，编译器会自动推导。fun main() { var age = 27 // age is Int val name = &quot;Belin Wu&quot; // name is String}字符串模板字符串里可以直接嵌套变量或表达式。fun main() { val name = &quot;Kotlin&quot; println(&quot;The length of $name is ${name.length}&quot;) // The length of Kotlin is 6}原始字符串用三引号&quot;&quot;&quot;定义的字符串里可以包含任意字符，不需要转义。fun main() { val text = &quot;&quot;&quot; for (c in &quot;foo&quot;) print(c)&quot;&quot;&quot; print(text)}没有new直接调用构造函数就可以创建实例。fun main() { val version = KotlinVersion(1, 1, 51)}属性不用定义setter和getter方法。class User(var name: String)fun main() { val u = User(&quot;Belin&quot;) u.name = &quot;Belin Wu&quot; println(&quot;My name is ${u.name}&quot;)}定义对象对象声明将类的声明和实例创建结合了起来，一步到位。Singleton同时也是一个单例。object Singletonfun main() { println(Singleton) // Singleton@6e0be858 println(Singleton::class) // class Singleton}类型检查与智能转换判断对象是不是某个类型用is；判断对象不是某个类型用!isfun main() { val obj: Any = &quot;Kotlin&quot; println(obj is String) // true println(obj !is String) // false}确定对象是期望的类型后就可以直接调用它的属性或成员函数，不需要强制类型转换。fun main() { val obj: Any = &quot;Kotlin&quot; if (obj is String) { println(obj.length) }}类型别名为已有类型定义别名有缩短类型名称、让名字更符合使用场景、简化范型或函数类型等好处。typealias Age = Bytetypealias Hobby = Set&amp;lt;String&amp;gt;typealias Predicate&amp;lt;T&amp;gt; = (T) -&amp;gt; Booleanclass Url { inner class Builder}typealias UrlBuilder = Url.Builder可空类型Kotlin 类型分为：可空类型、不可空类型。null只允许将赋值给可空类型，否则会出现编译错误。fun main() { val str: String? = null val error: String = null // compile error}在类型的后面加上?就是该类型对应的可空类型。调用可空类型的属性或成员函数有一种安全的操作符：?.，当调用者是null时，调用结果也为null。当在多个可空类型上做级联调用时可以省去嵌套if判断，代码更加简洁。fun main() { val str: String? = null str?.length?.toString()?.length / / null}默认参数值有默认值的函数可以减少重载、困惑。fun joinToString(array: Array&amp;lt;String&amp;gt;, separator: String = &quot;, &quot;): String { return array.joinToString(separator)}fun main() { joinToString(args) joinToString(args, &quot; &quot;)}数据类当使用data class定义数据类时，编译器会自动生成toString()，equals()，hashCode()，copy()等成员函数的字节码。data class User(val name: String, var age: Int)fun main() { val user = User(&quot;Belin Wu&quot;, 27) user.equals(user) // true user.hashCode() // hash code user.copy(age = 28) // copy the user to new user and modify the age property println(user.toString()) // User(name=Belin Wu, age=27)}解构声明将对象解构可以一次性声明并初始化多个变量。data class User(var name: String, var age: Int = 1)fun main() { val u = User(&quot;Belin&quot;) val (name, age) = u print(&quot;name is $name, age is $age&quot;)}多返回值使用解构声明可以实现返回多值的函数。fun main() { val (father, mother) = getParent() println(father.name) println(mother.name)}fun getParent(): Pair&amp;lt;Person, Person&amp;gt; { return Pair(Person(&quot;Father&quot;), Person(&quot;Mother&quot;))}class Person(var name: String)Pair&amp;lt;A, B&amp;gt;是一个内置的数据类，它有component1和component2方法，Kotlin编译器会按顺序一一调用componentN方法并将结果分别赋值给father和mother变量。其中component1方法返回类声明的第一个属性，而component2方法返回第二个属性，依此类推。举一反三，使用另一个内置的数据类Triple&amp;lt;A, B, C&amp;gt;就可以实现三个返回值的函数。要一定是数据类吗？并不是，按照约定，在类中有定义N个componentN方法即可。class MyPair&amp;lt;out A, out B&amp;gt;(val a: A, val b: B) { operator fun component1() = a operator fun component2() = b}不再需要中间变量，代码更简洁。Delegation 机制interface Base { fun print()}class BaseImpl(val x: Int) : Base { override fun print() { print(x) }}class Derived(b: Base) : Base by bfun main() { val b = BaseImpl(10) Derived(b).print()}参考资料 Kotlin in Action Kotlin Reference" }, { "title": "Android ImageView的scaleType属性", "url": "/posts/android-image-scale-type/", "categories": "Android", "tags": "", "date": "2017-01-05 20:51:00 +0000", "snippet": "ImageView 的 android:scaleType 属性的含义如下：控制如何调整图片大小和图片位移以匹配 ImageView 的大小（即宽和高）。它有以下几个值： 属性值 代码值 center ImageView.ScaleType.CENTER centerCrop ImageView.ScaleType.CENTER_CROP centerInside ImageView.ScaleType.CENTER_INSIDE fitCenter ImageView.ScaleType.FIT_CENTER fitStart ImageView.ScaleType.FIT_START fitEnd ImageView.ScaleType.FIT_END fitXY ImageView.ScaleType.FIT_XY matrix ImageView.ScaleType.MATRIX 默认值为：fitCenter。1. 精解以下使用两个宽高均为：400x400px 的 ImageView 控件来分别展示宽高为：125x127px 和 678x674px 的图片。ImageView 控件的背景色均为红色，他们的父视图背景色为灰色。1.1 center图片保持原始宽高。将图片居中展示在 ImageView 里，超出 ImageView 宽高的部分将被截去。1.2 centerCrop等比例缩放图片使得图片的宽高都分别 &amp;gt;= ImageView 的宽高（减去 padding），接着截取缩放后的图片的中间部分。1.3 centerInside图片居中展示在 ImageView 里，若图片大小 &amp;gt; ImageView 大小，则将图片等比列缩小，使得整张图片都能完全展示在 ImageView 里，也就是说图片水平和垂直方向至少有一方向上的边与 ImageView 的边对齐。1.4 fitCenter (默认值)等比列缩放图片使得图片水平和垂直方向至少有一方向上的边与 ImageView 的边对齐，最后将图片居中显示在 ImageView 里。1.5 fitStart与 fitCenter 缩放规则相同，最后使图片的上边和左边都分别与 ImageView 的上边和左边对齐。1.6 fitEnd与 fitCenter 缩放规则相同，最后使图片的下边和右边都分别与 ImageView 的下边和右边对齐。1.7 fitXY不等比例缩放图片，使得图片的四边与 ImageView 的四边都对齐。1.8 matrix矩阵被用于在图形绘制时操作画布。对于 ImageView 而言，矩阵可以用于位移图片、翻转图片、旋转图片等，尤其是涉及用户手势相关的操作。待续2. 总结 当图片比 ImageView 小时，center 和 centerInside 的展示效果是相同的。 当图片比 ImageView 大时，centerInside 和 fitCenter 的展示效果是相同的。 fitCenter、fitStart 和 fitEnd 这三个的缩放规则是一样的，区别在于缩放后图片位移不同。 当希望匹配图片的宽高比，尤其是在使用 fitXY 这一属性值时，可以设置 adjustViewBounds=true。3. 参考资料 Working with the ImageView Tanis.7x’s Answer" } ]
