<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://belinwu.com/</id><title>Belin Wu</title><subtitle>Pragmatic Android Developer</subtitle> <updated>2021-10-24T10:02:46+00:00</updated> <author> <name>Belin Wu</name> <uri>https://belinwu.com/</uri> </author><link rel="self" type="application/atom+xml" href="https://belinwu.com/feed.xml"/><link rel="alternate" type="text/html" hreflang="en" href="https://belinwu.com/"/> <generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator> <rights> © 2021 Belin Wu </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>小心 getLaunchIntentForPackage() 方法</title><link href="https://belinwu.com/posts/beware-of-getLaunchIntentForPackage/" rel="alternate" type="text/html" title="小心 getLaunchIntentForPackage() 方法" /><published>2019-01-10T15:44:00+00:00</published> <updated>2019-01-10T15:44:00+00:00</updated> <id>https://belinwu.com/posts/beware-of-getLaunchIntentForPackage/</id> <content src="https://belinwu.com/posts/beware-of-getLaunchIntentForPackage/" /> <author> <name>Belin Wu</name> </author> <category term="Android" /> <summary> 应用中响应 android.intent.action.MAIN 和 android.intent.category.LAUNCHER 在本文中称为主界面。 本文基于 Android O 问题现象 用PackageInstaller安装应用，在安装完成界面里点击打开，应用闪屏页打开后，按Home键回到桌面，点击桌面里的应用图标。 问题点：再打开一个闪屏页。 问题原因 应用中启动别的应用，以上问题场景使用的是 PackageManager#getLaunchIntentForPackage() 这个API，它的实现是： // frameworks\base\core\java\android\app\ApplicationPackageManager.java @Override public Intent getLaunchIntentFo... </summary> </entry> <entry><title>剖析Android架构组件之ViewModel</title><link href="https://belinwu.com/posts/decompose-viewmodel/" rel="alternate" type="text/html" title="剖析Android架构组件之ViewModel" /><published>2018-07-15T17:01:00+00:00</published> <updated>2018-07-15T17:01:00+00:00</updated> <id>https://belinwu.com/posts/decompose-viewmodel/</id> <content src="https://belinwu.com/posts/decompose-viewmodel/" /> <author> <name>Belin Wu</name> </author> <category term="Android" /> <summary> ViewModel 是 Android 架构组件之一，用于分离 UI 逻辑与 UI 数据。在发生 Configuration Changes 时，它不会被销毁。在界面重建后，方便开发者呈现界面销毁前的 UI 状态。 本文主要分析 ViewModel 的以下3个方面： 获取和创建过程。 Configuration Changes 存活原理。 销毁过程。 1. 依赖库 implementation "androidx.fragment:fragment:1.0.0" implementation "androidx.lifecycle:lifecycle-viewmodel:2.0.0" implementation "androidx.lifecycle:lifecycle-extensions:2.0.0" 2. 主要类与接口 import androi... </summary> </entry> <entry><title>初学Android架构组件之ViewModel</title><link href="https://belinwu.com/posts/learn-viewmodel/" rel="alternate" type="text/html" title="初学Android架构组件之ViewModel" /><published>2018-07-14T23:23:00+00:00</published> <updated>2021-10-20T12:45:13+00:00</updated> <id>https://belinwu.com/posts/learn-viewmodel/</id> <content src="https://belinwu.com/posts/learn-viewmodel/" /> <author> <name>Belin Wu</name> </author> <category term="Android" /> <summary> 在 Android 中，Activity 和 Fragment 这类 UI 组件会被系统销毁或重建，未特殊处理的 UI 数据将会丢失。以往处理这类问题时，会使用 onSaveInstanceState() 保存 UI 数据，在 onCreate() 方法里恢复 UI 数据，但是数据的大小和类型有限制。 看看下面的2个问题： 对于因手机 Configuration Changes 而被系统重建的界面，为了呈现之前的 UI 状态，采用上述的方式来实现起来会显得过于繁琐、不优雅。 在实践 Separation of Concerns 准则时，UI 组件主要是负责显示 UI 数据、响应系统与视图事件，若再负责数据的加载和管理，会变得臃肿、不易复用。 本文的主角 ViewModel 可以很好地解决这些问题。注意：它不是用来代替 onSaveInstanceState()。 ... </summary> </entry> <entry><title>组合优于继承</title><link href="https://belinwu.com/posts/composition-over-inheritance/" rel="alternate" type="text/html" title="组合优于继承" /><published>2018-07-11T09:51:00+00:00</published> <updated>2021-10-18T11:22:46+00:00</updated> <id>https://belinwu.com/posts/composition-over-inheritance/</id> <content src="https://belinwu.com/posts/composition-over-inheritance/" /> <author> <name>Belin Wu</name> </author> <category term="编程" /> <summary> 《Effective Java 中文版第2版》书中第16条中说到： 继承是实现代码复用的有力手段，但它并非永远是完成这项工作的的最佳工具。 继承有什么问题？ 继承打破了类的封装性，子类依赖于父类中特定功能的实现细节。 继承什么时候是安全的 在包的内部是用继承，不存在跨包继承。 专门为了扩展而设计，并且具备很好的文档说明。 一个例子 实现这样一个HashSet，可以跟踪从它被创建之后曾经添加过几个元素。 使用继承实现 public class InstrumentedSet&amp;lt;E&amp;gt; extends HashSet&amp;lt;E&amp;gt; { // The number of attempted element insertions private int addCount = 0; public InstrumentedSet()... </summary> </entry> <entry><title>初学Android架构组件之Lifecycle</title><link href="https://belinwu.com/posts/learn-lifecycle/" rel="alternate" type="text/html" title="初学Android架构组件之Lifecycle" /><published>2018-06-29T13:54:00+00:00</published> <updated>2018-06-29T13:54:00+00:00</updated> <id>https://belinwu.com/posts/learn-lifecycle/</id> <content src="https://belinwu.com/posts/learn-lifecycle/" /> <author> <name>Belin Wu</name> </author> <category term="Android" /> <summary> 在开发应用时，我们可能会基于一系列的生命周期实现某种功能。为了复用，也为了不让应用组件变得很臃肿，实现该功能时会选择与生命周期组件解藕，独立成一种组件。这样能够很方便地在应用组件中使用，比如：Activity、Fragment 或 Service。 Android 官方把它叫做 lifecycle-aware 组件，这类组件能够感知应用组件生命周期的变化，避免一连串显性的生命周期方法委托调用。虽然可以创建基类，在基类中进行委托调用，但由于 Java 是单继承的，就会存在一定的限制。不然发现，这是一次组合优于继承的实践。 为了方便开发者创建 lifecycle-aware 组件，androidx.lifecycle 包提供了一些类与接口。 Lifecycle Lifecycle 类表示Android应用组件的生命周期，是被观察者。这是一个抽象类，它的实现是 LifecycleR... </summary> </entry> </feed>
